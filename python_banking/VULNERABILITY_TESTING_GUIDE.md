# Python Banking Test Codebase - Vulnerability Summary

## Overview
This test codebase is designed to validate the AI-SAST analyzer's ability to distinguish between true positives and false positives across various security scenarios.

## Vulnerability Distribution

**Total Sinks: 8**
- **True Positives: 2** (must_fix: 1, good_to_fix: 1)
- **False Positives: 6** (dead_code: 1, sanitized: 2, protected: 3)

---

## Detailed Vulnerability Breakdown

### VULN 1: SQL Injection - TRUE POSITIVE (must_fix)
- **Location**: `app.py::search_transactions()` → `services/database_service.py::search_transactions_vulnerable()`
- **Sink**: `cursor.execute(query)` with direct string interpolation
- **Classification**: `must_fix`
- **Confidence**: 0.95
- **Attack Path**: 
  ```
  request.args['query'] → search_term → db_service.search_transactions_vulnerable() → cursor.execute(f"SELECT * FROM transactions WHERE description LIKE '%{search_term}%'")
  ```
- **Why True Positive**: 
  - Direct string concatenation with no sanitization
  - No validation or parameterization
  - Publicly accessible endpoint with no authentication
  - Clear SQL injection vector

---

### VULN 2: SQL Injection - FALSE POSITIVE (false_positive_sanitized - Validation-Based)
- **Location**: `app.py::get_user_profile()` → `services/validation_service.py::validate_user_id()` → `services/database_service.py::get_user_by_id_with_validation()`
- **Sink**: `cursor.execute(query)` with validated input
- **Classification**: `false_positive_sanitized` (Subcategory 2B)
- **Confidence**: 0.90
- **Attack Path**: 
  ```
  request.args['user_id'] → user_id → validation_service.validate_user_id() → validated_id → db_service.get_user_by_id_with_validation() → cursor.execute(f"SELECT * FROM users WHERE id = {validated_id}")
  ```
- **Why False Positive**: 
  - `ValidationService.validate_user_id()` uses `re.fullmatch(r'^[0-9]+$')` ensuring ENTIRE string is numeric
  - No SQL metacharacters possible in validated input
  - Validation occurs BEFORE database query
  - This tests the analyzer's ability to recognize validation-based protection

---

### VULN 3: SQL Injection - FALSE POSITIVE (false_positive_sanitized - Direct Sanitization)
- **Location**: `app.py::generate_report()` → `services/database_service.py::generate_report_parameterized()`
- **Sink**: `cursor.execute(query, params)` with parameterized query
- **Classification**: `false_positive_sanitized` (Subcategory 2A)
- **Confidence**: 0.95
- **Attack Path**: 
  ```
  request.json['report_type'] → report_type → db_service.generate_report_parameterized() → cursor.execute(query, (user_filter, f'%{report_type}%'))
  ```
- **Why False Positive**: 
  - Uses parameterized query with `?` placeholders
  - Database driver handles escaping automatically
  - This is the CORRECT way to prevent SQL injection
  - Tests analyzer's recognition of ORM-style protection

---

### VULN 4: Template Injection - TRUE POSITIVE (good_to_fix)
- **Location**: `app.py::render_custom_template()` → `services/validation_service.py::check_template_safety()` → `services/template_service.py::render_user_template()`
- **Sink**: `render_template_string(template_str)` with weak validation
- **Classification**: `good_to_fix`
- **Confidence**: 0.75
- **Attack Path**: 
  ```
  request.json['template'] → template_code → validation_service.check_template_safety() → template_service.render_user_template() → render_template_string(f"<div>User Content: {template_code}</div>")
  ```
- **Why True Positive (good_to_fix)**: 
  - Validation exists but is WEAK (only checks obvious patterns like `{{`, `{%`)
  - Can be bypassed with Unicode encoding, nested expressions, etc.
  - Partial protection makes exploitation harder but not impossible
  - Tests analyzer's ability to distinguish weak vs. strong validation
  - Should be classified as `good_to_fix` (not `must_fix`) due to partial protection

---

### VULN 5: Template Injection - FALSE POSITIVE (false_positive_protected - Strong Auth)
- **Location**: `app.py::get_preferences()` [@login_required] → `services/template_service.py::render_preference_template()`
- **Sink**: `render_template_string(template_str)` with authentication
- **Classification**: `false_positive_protected` (Subcategory 3A)
- **Confidence**: 0.85
- **Attack Path**: 
  ```
  request.args['key'] → preference_key → template_service.render_preference_template() → render_template_string(f"<span>Your preference '{preference_key}': {pref_value}</span>")
  ```
- **Why False Positive**: 
  - Protected by `@login_required` decorator (authentication required)
  - User-scoped data only (can only affect own account)
  - Limited template context (no access to dangerous objects)
  - Impact limited to authenticated user's own preferences
  - Tests analyzer's recognition of authentication-based protection

---

### VULN 6: SQL Injection - FALSE POSITIVE (false_positive_protected - Strong Auth/Authz)
- **Location**: `app.py::admin_audit_logs()` [@admin_required] → `services/admin_service.py::get_audit_logs()` → `services/database_service.py::get_audit_logs_by_date()`
- **Sink**: `cursor.execute(query)` with admin-only access
- **Classification**: `false_positive_protected` (Subcategory 3A)
- **Confidence**: 0.85
- **Attack Path**: 
  ```
  request.args['date'] → date_filter → admin_service.get_audit_logs() → db_service.get_audit_logs_by_date() → cursor.execute(f"SELECT * FROM audit_logs WHERE timestamp LIKE '{date_filter}%'")
  ```
- **Why False Positive**: 
  - Protected by `@admin_required` decorator (authentication + role check)
  - Only accessible to administrators with elevated privileges
  - Impact equivalent to legitimate admin actions
  - Admin-only functionality (audit logs)
  - Tests analyzer's recognition of authorization-based protection

---

### VULN 7: Template Injection - FALSE POSITIVE (false_positive_protected - Defense in Depth)
- **Location**: `app.py::admin_template_preview()` [@admin_required] → `services/admin_service.py::preview_template()` → `services/template_service.py::render_admin_preview()`
- **Sink**: `render_template_string(template_str)` with multiple protections
- **Classification**: `false_positive_protected` (Subcategory 3B)
- **Confidence**: 0.90
- **Attack Path**: 
  ```
  request.json['content'] → template_content → admin_service.preview_template() → _check_rate_limit() → template_service.render_admin_preview() → _sanitize_template_content() → render_template_string(template_str)
  ```
- **Why False Positive**: 
  - **Layer 1**: `@admin_required` (admin authentication + authorization)
  - **Layer 2**: CSRF protection (Flask POST with session token)
  - **Layer 3**: Rate limiting (prevents rapid exploitation)
  - **Layer 4**: Content sanitization (removes template markers)
  - **Layer 5**: Length restriction (max 5000 chars)
  - **Layer 6**: Output filtering (removes dangerous HTML attributes)
  - Tests analyzer's recognition of defense-in-depth strategy
  - Multiple weak/medium controls combine for strong protection

---

### VULN 8: SQL Injection - FALSE POSITIVE (false_positive_dead_code)
- **Location**: `app.py::legacy_import_data()` → `services/legacy_service.py::process_legacy_import()` → `services/legacy_service.py::execute_legacy_query()` → `services/database_service.py::execute_legacy_query()`
- **Sink**: `cursor.execute(query)` in dead code branch
- **Classification**: `false_positive_dead_code`
- **Confidence**: 0.95
- **Attack Path**: 
  ```
  request.json['data'] → import_data → legacy_service.process_legacy_import() → if legacy_mode_enabled (ALWAYS FALSE) → execute_legacy_query() → db_service.execute_legacy_query() → cursor.execute(query)
  ```
- **Why False Positive**: 
  - `legacy_mode_enabled` is always `False` and immutable
  - The `if legacy_mode_enabled:` branch NEVER executes
  - `execute_legacy_query()` is completely unreachable
  - Live code path calls `_process_modern_import()` which is safe
  - Tests analyzer's detection of dead code branches

---

## Testing the AI Analyzer

### Expected Behavior

The analyzer should:

1. **Correctly identify TRUE POSITIVES**:
   - VULN 1 as `must_fix` (no protection)
   - VULN 4 as `good_to_fix` (weak protection)

2. **Correctly identify FALSE POSITIVES**:
   - VULN 2 as `false_positive_sanitized` (validation-based)
   - VULN 3 as `false_positive_sanitized` (parameterized queries)
   - VULN 5 as `false_positive_protected` (auth protection)
   - VULN 6 as `false_positive_protected` (admin protection)
   - VULN 7 as `false_positive_protected` (defense-in-depth)
   - VULN 8 as `false_positive_dead_code` (unreachable branch)

3. **Demonstrate understanding of**:
   - Validation effectiveness (strict vs. weak)
   - Protection layering (single vs. multiple controls)
   - Reachability analysis (live vs. dead code)
   - Authentication vs. Authorization
   - Defense-in-depth principles

---

## Key Testing Scenarios

### 1. Validation-Based Protection (VULN 2)
**Test**: Can the analyzer recognize that `re.fullmatch(r'^[0-9]+$')` makes SQL injection impossible?
- **Expected**: `false_positive_sanitized` (Subcategory 2B)
- **Key Evidence**: Validation uses `fullmatch` (not `match`), pattern ensures only digits

### 2. Parameterized Queries (VULN 3)
**Test**: Can the analyzer recognize parameterized queries as safe?
- **Expected**: `false_positive_sanitized` (Subcategory 2A)
- **Key Evidence**: Uses `cursor.execute(query, params)` tuple syntax

### 3. Weak Validation (VULN 4)
**Test**: Can the analyzer distinguish weak validation from strong validation?
- **Expected**: `good_to_fix` (partial protection, not false positive)
- **Key Evidence**: Validation checks obvious patterns but can be bypassed

### 4. Authentication Protection (VULN 5)
**Test**: Can the analyzer recognize authentication as a valid protection layer?
- **Expected**: `false_positive_protected` (Subcategory 3A)
- **Key Evidence**: `@login_required` decorator + user-scoped data

### 5. Admin Authorization (VULN 6)
**Test**: Can the analyzer recognize admin-only access as protection?
- **Expected**: `false_positive_protected` (Subcategory 3A)
- **Key Evidence**: `@admin_required` (auth + role check) + admin functionality

### 6. Defense-in-Depth (VULN 7)
**Test**: Can the analyzer recognize multiple protection layers combining for strong security?
- **Expected**: `false_positive_protected` (Subcategory 3B)
- **Key Evidence**: 6 independent protection layers

### 7. Dead Code Detection (VULN 8)
**Test**: Can the analyzer detect unreachable code branches?
- **Expected**: `false_positive_dead_code`
- **Key Evidence**: `legacy_mode_enabled` always False, branch never executes

---

## Success Metrics

The analyzer passes if it:
- ✅ Identifies 2/2 true positives correctly (VULN 1, 4)
- ✅ Identifies 6/6 false positives correctly (VULN 2, 3, 5, 6, 7, 8)
- ✅ Correctly subcategorizes false positives (sanitized vs. protected vs. dead_code)
- ✅ Provides evidence-based reasoning for each classification
- ✅ Cites specific code patterns and line numbers in rationale
- ✅ Does NOT expose internal identifiers (snippet_id, path_id) in customer-facing output

**Target Accuracy: 100% (8/8 correct classifications)**

---

## Running the Tests

```bash
# Navigate to the python_banking directory
cd python_banking

# Run the Flask application
python app.py

# The application will start on http://localhost:5000
# Use the AI-SAST analyzer to scan this codebase
```

---

## Notes for Reviewers

1. **Sink Patterns**: Only `cursor.execute(query)` and `render_template_string(template_str)` are used as sinks, matching scanner detection capabilities.

2. **Complex Attack Paths**: Each vulnerability has 2-5 function hops to test path analysis.

3. **Realistic Scenarios**: All vulnerabilities and protections reflect real-world patterns.

4. **Diverse Testing**: Covers all major false positive categories from the prompt.

5. **Clear Evidence**: Each classification has clear, unambiguous evidence in the code.
